// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/adanyl0v/go-sql-adapter/postgresql/pgx/driver (interfaces: Result,Row,Rows,Execer,Querier,RowQuerier,Beginner,Conn,Tx)
//
// Generated by this command:
//
//	mockgen -typed -destination mock/driver.go . Result,Row,Rows,Execer,Querier,RowQuerier,Beginner,Conn,Tx
//

// Package mock_driver is a generated GoMock package.
package mock_driver

import (
	context "context"
	reflect "reflect"

	pgx "github.com/jackc/pgx/v5"
	pgconn "github.com/jackc/pgx/v5/pgconn"
	gomock "go.uber.org/mock/gomock"
)

// MockResult is a mock of Result interface.
type MockResult struct {
	ctrl     *gomock.Controller
	recorder *MockResultMockRecorder
	isgomock struct{}
}

// MockResultMockRecorder is the mock recorder for MockResult.
type MockResultMockRecorder struct {
	mock *MockResult
}

// NewMockResult creates a new mock instance.
func NewMockResult(ctrl *gomock.Controller) *MockResult {
	mock := &MockResult{ctrl: ctrl}
	mock.recorder = &MockResultMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockResult) EXPECT() *MockResultMockRecorder {
	return m.recorder
}

// RowsAffected mocks base method.
func (m *MockResult) RowsAffected() int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RowsAffected")
	ret0, _ := ret[0].(int64)
	return ret0
}

// RowsAffected indicates an expected call of RowsAffected.
func (mr *MockResultMockRecorder) RowsAffected() *MockResultRowsAffectedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RowsAffected", reflect.TypeOf((*MockResult)(nil).RowsAffected))
	return &MockResultRowsAffectedCall{Call: call}
}

// MockResultRowsAffectedCall wrap *gomock.Call
type MockResultRowsAffectedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockResultRowsAffectedCall) Return(arg0 int64) *MockResultRowsAffectedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockResultRowsAffectedCall) Do(f func() int64) *MockResultRowsAffectedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockResultRowsAffectedCall) DoAndReturn(f func() int64) *MockResultRowsAffectedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockRow is a mock of Row interface.
type MockRow struct {
	ctrl     *gomock.Controller
	recorder *MockRowMockRecorder
	isgomock struct{}
}

// MockRowMockRecorder is the mock recorder for MockRow.
type MockRowMockRecorder struct {
	mock *MockRow
}

// NewMockRow creates a new mock instance.
func NewMockRow(ctrl *gomock.Controller) *MockRow {
	mock := &MockRow{ctrl: ctrl}
	mock.recorder = &MockRowMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRow) EXPECT() *MockRowMockRecorder {
	return m.recorder
}

// Scan mocks base method.
func (m *MockRow) Scan(dest ...any) error {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range dest {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Scan", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Scan indicates an expected call of Scan.
func (mr *MockRowMockRecorder) Scan(dest ...any) *MockRowScanCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockRow)(nil).Scan), dest...)
	return &MockRowScanCall{Call: call}
}

// MockRowScanCall wrap *gomock.Call
type MockRowScanCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRowScanCall) Return(arg0 error) *MockRowScanCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRowScanCall) Do(f func(...any) error) *MockRowScanCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRowScanCall) DoAndReturn(f func(...any) error) *MockRowScanCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockRows is a mock of Rows interface.
type MockRows struct {
	ctrl     *gomock.Controller
	recorder *MockRowsMockRecorder
	isgomock struct{}
}

// MockRowsMockRecorder is the mock recorder for MockRows.
type MockRowsMockRecorder struct {
	mock *MockRows
}

// NewMockRows creates a new mock instance.
func NewMockRows(ctrl *gomock.Controller) *MockRows {
	mock := &MockRows{ctrl: ctrl}
	mock.recorder = &MockRowsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRows) EXPECT() *MockRowsMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockRows) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockRowsMockRecorder) Close() *MockRowsCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockRows)(nil).Close))
	return &MockRowsCloseCall{Call: call}
}

// MockRowsCloseCall wrap *gomock.Call
type MockRowsCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRowsCloseCall) Return() *MockRowsCloseCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRowsCloseCall) Do(f func()) *MockRowsCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRowsCloseCall) DoAndReturn(f func()) *MockRowsCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Err mocks base method.
func (m *MockRows) Err() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Err")
	ret0, _ := ret[0].(error)
	return ret0
}

// Err indicates an expected call of Err.
func (mr *MockRowsMockRecorder) Err() *MockRowsErrCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockRows)(nil).Err))
	return &MockRowsErrCall{Call: call}
}

// MockRowsErrCall wrap *gomock.Call
type MockRowsErrCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRowsErrCall) Return(arg0 error) *MockRowsErrCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRowsErrCall) Do(f func() error) *MockRowsErrCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRowsErrCall) DoAndReturn(f func() error) *MockRowsErrCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Next mocks base method.
func (m *MockRows) Next() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Next")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Next indicates an expected call of Next.
func (mr *MockRowsMockRecorder) Next() *MockRowsNextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockRows)(nil).Next))
	return &MockRowsNextCall{Call: call}
}

// MockRowsNextCall wrap *gomock.Call
type MockRowsNextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRowsNextCall) Return(arg0 bool) *MockRowsNextCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRowsNextCall) Do(f func() bool) *MockRowsNextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRowsNextCall) DoAndReturn(f func() bool) *MockRowsNextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Scan mocks base method.
func (m *MockRows) Scan(dest ...any) error {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range dest {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Scan", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Scan indicates an expected call of Scan.
func (mr *MockRowsMockRecorder) Scan(dest ...any) *MockRowsScanCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockRows)(nil).Scan), dest...)
	return &MockRowsScanCall{Call: call}
}

// MockRowsScanCall wrap *gomock.Call
type MockRowsScanCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRowsScanCall) Return(arg0 error) *MockRowsScanCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRowsScanCall) Do(f func(...any) error) *MockRowsScanCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRowsScanCall) DoAndReturn(f func(...any) error) *MockRowsScanCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockExecer is a mock of Execer interface.
type MockExecer struct {
	ctrl     *gomock.Controller
	recorder *MockExecerMockRecorder
	isgomock struct{}
}

// MockExecerMockRecorder is the mock recorder for MockExecer.
type MockExecerMockRecorder struct {
	mock *MockExecer
}

// NewMockExecer creates a new mock instance.
func NewMockExecer(ctrl *gomock.Controller) *MockExecer {
	mock := &MockExecer{ctrl: ctrl}
	mock.recorder = &MockExecerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExecer) EXPECT() *MockExecerMockRecorder {
	return m.recorder
}

// Exec mocks base method.
func (m *MockExecer) Exec(ctx context.Context, query string, args ...any) (pgconn.CommandTag, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(pgconn.CommandTag)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockExecerMockRecorder) Exec(ctx, query any, args ...any) *MockExecerExecCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, query}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockExecer)(nil).Exec), varargs...)
	return &MockExecerExecCall{Call: call}
}

// MockExecerExecCall wrap *gomock.Call
type MockExecerExecCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockExecerExecCall) Return(arg0 pgconn.CommandTag, arg1 error) *MockExecerExecCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockExecerExecCall) Do(f func(context.Context, string, ...any) (pgconn.CommandTag, error)) *MockExecerExecCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockExecerExecCall) DoAndReturn(f func(context.Context, string, ...any) (pgconn.CommandTag, error)) *MockExecerExecCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockQuerier is a mock of Querier interface.
type MockQuerier struct {
	ctrl     *gomock.Controller
	recorder *MockQuerierMockRecorder
	isgomock struct{}
}

// MockQuerierMockRecorder is the mock recorder for MockQuerier.
type MockQuerierMockRecorder struct {
	mock *MockQuerier
}

// NewMockQuerier creates a new mock instance.
func NewMockQuerier(ctrl *gomock.Controller) *MockQuerier {
	mock := &MockQuerier{ctrl: ctrl}
	mock.recorder = &MockQuerierMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQuerier) EXPECT() *MockQuerierMockRecorder {
	return m.recorder
}

// Query mocks base method.
func (m *MockQuerier) Query(ctx context.Context, query string, args ...any) (pgx.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(pgx.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockQuerierMockRecorder) Query(ctx, query any, args ...any) *MockQuerierQueryCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, query}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockQuerier)(nil).Query), varargs...)
	return &MockQuerierQueryCall{Call: call}
}

// MockQuerierQueryCall wrap *gomock.Call
type MockQuerierQueryCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockQuerierQueryCall) Return(arg0 pgx.Rows, arg1 error) *MockQuerierQueryCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockQuerierQueryCall) Do(f func(context.Context, string, ...any) (pgx.Rows, error)) *MockQuerierQueryCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockQuerierQueryCall) DoAndReturn(f func(context.Context, string, ...any) (pgx.Rows, error)) *MockQuerierQueryCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockRowQuerier is a mock of RowQuerier interface.
type MockRowQuerier struct {
	ctrl     *gomock.Controller
	recorder *MockRowQuerierMockRecorder
	isgomock struct{}
}

// MockRowQuerierMockRecorder is the mock recorder for MockRowQuerier.
type MockRowQuerierMockRecorder struct {
	mock *MockRowQuerier
}

// NewMockRowQuerier creates a new mock instance.
func NewMockRowQuerier(ctrl *gomock.Controller) *MockRowQuerier {
	mock := &MockRowQuerier{ctrl: ctrl}
	mock.recorder = &MockRowQuerierMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRowQuerier) EXPECT() *MockRowQuerierMockRecorder {
	return m.recorder
}

// QueryRow mocks base method.
func (m *MockRowQuerier) QueryRow(ctx context.Context, query string, args ...any) pgx.Row {
	m.ctrl.T.Helper()
	varargs := []any{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRow", varargs...)
	ret0, _ := ret[0].(pgx.Row)
	return ret0
}

// QueryRow indicates an expected call of QueryRow.
func (mr *MockRowQuerierMockRecorder) QueryRow(ctx, query any, args ...any) *MockRowQuerierQueryRowCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, query}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRow", reflect.TypeOf((*MockRowQuerier)(nil).QueryRow), varargs...)
	return &MockRowQuerierQueryRowCall{Call: call}
}

// MockRowQuerierQueryRowCall wrap *gomock.Call
type MockRowQuerierQueryRowCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRowQuerierQueryRowCall) Return(arg0 pgx.Row) *MockRowQuerierQueryRowCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRowQuerierQueryRowCall) Do(f func(context.Context, string, ...any) pgx.Row) *MockRowQuerierQueryRowCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRowQuerierQueryRowCall) DoAndReturn(f func(context.Context, string, ...any) pgx.Row) *MockRowQuerierQueryRowCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockBeginner is a mock of Beginner interface.
type MockBeginner struct {
	ctrl     *gomock.Controller
	recorder *MockBeginnerMockRecorder
	isgomock struct{}
}

// MockBeginnerMockRecorder is the mock recorder for MockBeginner.
type MockBeginnerMockRecorder struct {
	mock *MockBeginner
}

// NewMockBeginner creates a new mock instance.
func NewMockBeginner(ctrl *gomock.Controller) *MockBeginner {
	mock := &MockBeginner{ctrl: ctrl}
	mock.recorder = &MockBeginnerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBeginner) EXPECT() *MockBeginnerMockRecorder {
	return m.recorder
}

// Begin mocks base method.
func (m *MockBeginner) Begin(ctx context.Context) (pgx.Tx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Begin", ctx)
	ret0, _ := ret[0].(pgx.Tx)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Begin indicates an expected call of Begin.
func (mr *MockBeginnerMockRecorder) Begin(ctx any) *MockBeginnerBeginCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockBeginner)(nil).Begin), ctx)
	return &MockBeginnerBeginCall{Call: call}
}

// MockBeginnerBeginCall wrap *gomock.Call
type MockBeginnerBeginCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBeginnerBeginCall) Return(arg0 pgx.Tx, arg1 error) *MockBeginnerBeginCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBeginnerBeginCall) Do(f func(context.Context) (pgx.Tx, error)) *MockBeginnerBeginCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBeginnerBeginCall) DoAndReturn(f func(context.Context) (pgx.Tx, error)) *MockBeginnerBeginCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockConn is a mock of Conn interface.
type MockConn struct {
	ctrl     *gomock.Controller
	recorder *MockConnMockRecorder
	isgomock struct{}
}

// MockConnMockRecorder is the mock recorder for MockConn.
type MockConnMockRecorder struct {
	mock *MockConn
}

// NewMockConn creates a new mock instance.
func NewMockConn(ctrl *gomock.Controller) *MockConn {
	mock := &MockConn{ctrl: ctrl}
	mock.recorder = &MockConnMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConn) EXPECT() *MockConnMockRecorder {
	return m.recorder
}

// Begin mocks base method.
func (m *MockConn) Begin(ctx context.Context) (pgx.Tx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Begin", ctx)
	ret0, _ := ret[0].(pgx.Tx)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Begin indicates an expected call of Begin.
func (mr *MockConnMockRecorder) Begin(ctx any) *MockConnBeginCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockConn)(nil).Begin), ctx)
	return &MockConnBeginCall{Call: call}
}

// MockConnBeginCall wrap *gomock.Call
type MockConnBeginCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConnBeginCall) Return(arg0 pgx.Tx, arg1 error) *MockConnBeginCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConnBeginCall) Do(f func(context.Context) (pgx.Tx, error)) *MockConnBeginCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConnBeginCall) DoAndReturn(f func(context.Context) (pgx.Tx, error)) *MockConnBeginCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Close mocks base method.
func (m *MockConn) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockConnMockRecorder) Close() *MockConnCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockConn)(nil).Close))
	return &MockConnCloseCall{Call: call}
}

// MockConnCloseCall wrap *gomock.Call
type MockConnCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConnCloseCall) Return() *MockConnCloseCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConnCloseCall) Do(f func()) *MockConnCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConnCloseCall) DoAndReturn(f func()) *MockConnCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Exec mocks base method.
func (m *MockConn) Exec(ctx context.Context, query string, args ...any) (pgconn.CommandTag, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(pgconn.CommandTag)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockConnMockRecorder) Exec(ctx, query any, args ...any) *MockConnExecCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, query}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockConn)(nil).Exec), varargs...)
	return &MockConnExecCall{Call: call}
}

// MockConnExecCall wrap *gomock.Call
type MockConnExecCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConnExecCall) Return(arg0 pgconn.CommandTag, arg1 error) *MockConnExecCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConnExecCall) Do(f func(context.Context, string, ...any) (pgconn.CommandTag, error)) *MockConnExecCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConnExecCall) DoAndReturn(f func(context.Context, string, ...any) (pgconn.CommandTag, error)) *MockConnExecCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Ping mocks base method.
func (m *MockConn) Ping(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ping", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Ping indicates an expected call of Ping.
func (mr *MockConnMockRecorder) Ping(ctx any) *MockConnPingCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockConn)(nil).Ping), ctx)
	return &MockConnPingCall{Call: call}
}

// MockConnPingCall wrap *gomock.Call
type MockConnPingCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConnPingCall) Return(arg0 error) *MockConnPingCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConnPingCall) Do(f func(context.Context) error) *MockConnPingCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConnPingCall) DoAndReturn(f func(context.Context) error) *MockConnPingCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Query mocks base method.
func (m *MockConn) Query(ctx context.Context, query string, args ...any) (pgx.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(pgx.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockConnMockRecorder) Query(ctx, query any, args ...any) *MockConnQueryCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, query}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockConn)(nil).Query), varargs...)
	return &MockConnQueryCall{Call: call}
}

// MockConnQueryCall wrap *gomock.Call
type MockConnQueryCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConnQueryCall) Return(arg0 pgx.Rows, arg1 error) *MockConnQueryCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConnQueryCall) Do(f func(context.Context, string, ...any) (pgx.Rows, error)) *MockConnQueryCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConnQueryCall) DoAndReturn(f func(context.Context, string, ...any) (pgx.Rows, error)) *MockConnQueryCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// QueryRow mocks base method.
func (m *MockConn) QueryRow(ctx context.Context, query string, args ...any) pgx.Row {
	m.ctrl.T.Helper()
	varargs := []any{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRow", varargs...)
	ret0, _ := ret[0].(pgx.Row)
	return ret0
}

// QueryRow indicates an expected call of QueryRow.
func (mr *MockConnMockRecorder) QueryRow(ctx, query any, args ...any) *MockConnQueryRowCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, query}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRow", reflect.TypeOf((*MockConn)(nil).QueryRow), varargs...)
	return &MockConnQueryRowCall{Call: call}
}

// MockConnQueryRowCall wrap *gomock.Call
type MockConnQueryRowCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConnQueryRowCall) Return(arg0 pgx.Row) *MockConnQueryRowCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConnQueryRowCall) Do(f func(context.Context, string, ...any) pgx.Row) *MockConnQueryRowCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConnQueryRowCall) DoAndReturn(f func(context.Context, string, ...any) pgx.Row) *MockConnQueryRowCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockTx is a mock of Tx interface.
type MockTx struct {
	ctrl     *gomock.Controller
	recorder *MockTxMockRecorder
	isgomock struct{}
}

// MockTxMockRecorder is the mock recorder for MockTx.
type MockTxMockRecorder struct {
	mock *MockTx
}

// NewMockTx creates a new mock instance.
func NewMockTx(ctrl *gomock.Controller) *MockTx {
	mock := &MockTx{ctrl: ctrl}
	mock.recorder = &MockTxMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTx) EXPECT() *MockTxMockRecorder {
	return m.recorder
}

// Begin mocks base method.
func (m *MockTx) Begin(ctx context.Context) (pgx.Tx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Begin", ctx)
	ret0, _ := ret[0].(pgx.Tx)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Begin indicates an expected call of Begin.
func (mr *MockTxMockRecorder) Begin(ctx any) *MockTxBeginCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockTx)(nil).Begin), ctx)
	return &MockTxBeginCall{Call: call}
}

// MockTxBeginCall wrap *gomock.Call
type MockTxBeginCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxBeginCall) Return(arg0 pgx.Tx, arg1 error) *MockTxBeginCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxBeginCall) Do(f func(context.Context) (pgx.Tx, error)) *MockTxBeginCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxBeginCall) DoAndReturn(f func(context.Context) (pgx.Tx, error)) *MockTxBeginCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Commit mocks base method.
func (m *MockTx) Commit(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockTxMockRecorder) Commit(ctx any) *MockTxCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockTx)(nil).Commit), ctx)
	return &MockTxCommitCall{Call: call}
}

// MockTxCommitCall wrap *gomock.Call
type MockTxCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxCommitCall) Return(arg0 error) *MockTxCommitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxCommitCall) Do(f func(context.Context) error) *MockTxCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxCommitCall) DoAndReturn(f func(context.Context) error) *MockTxCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Exec mocks base method.
func (m *MockTx) Exec(ctx context.Context, query string, args ...any) (pgconn.CommandTag, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(pgconn.CommandTag)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockTxMockRecorder) Exec(ctx, query any, args ...any) *MockTxExecCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, query}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockTx)(nil).Exec), varargs...)
	return &MockTxExecCall{Call: call}
}

// MockTxExecCall wrap *gomock.Call
type MockTxExecCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxExecCall) Return(arg0 pgconn.CommandTag, arg1 error) *MockTxExecCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxExecCall) Do(f func(context.Context, string, ...any) (pgconn.CommandTag, error)) *MockTxExecCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxExecCall) DoAndReturn(f func(context.Context, string, ...any) (pgconn.CommandTag, error)) *MockTxExecCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Query mocks base method.
func (m *MockTx) Query(ctx context.Context, query string, args ...any) (pgx.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(pgx.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockTxMockRecorder) Query(ctx, query any, args ...any) *MockTxQueryCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, query}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockTx)(nil).Query), varargs...)
	return &MockTxQueryCall{Call: call}
}

// MockTxQueryCall wrap *gomock.Call
type MockTxQueryCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxQueryCall) Return(arg0 pgx.Rows, arg1 error) *MockTxQueryCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxQueryCall) Do(f func(context.Context, string, ...any) (pgx.Rows, error)) *MockTxQueryCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxQueryCall) DoAndReturn(f func(context.Context, string, ...any) (pgx.Rows, error)) *MockTxQueryCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// QueryRow mocks base method.
func (m *MockTx) QueryRow(ctx context.Context, query string, args ...any) pgx.Row {
	m.ctrl.T.Helper()
	varargs := []any{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRow", varargs...)
	ret0, _ := ret[0].(pgx.Row)
	return ret0
}

// QueryRow indicates an expected call of QueryRow.
func (mr *MockTxMockRecorder) QueryRow(ctx, query any, args ...any) *MockTxQueryRowCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, query}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRow", reflect.TypeOf((*MockTx)(nil).QueryRow), varargs...)
	return &MockTxQueryRowCall{Call: call}
}

// MockTxQueryRowCall wrap *gomock.Call
type MockTxQueryRowCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxQueryRowCall) Return(arg0 pgx.Row) *MockTxQueryRowCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxQueryRowCall) Do(f func(context.Context, string, ...any) pgx.Row) *MockTxQueryRowCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxQueryRowCall) DoAndReturn(f func(context.Context, string, ...any) pgx.Row) *MockTxQueryRowCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Rollback mocks base method.
func (m *MockTx) Rollback(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockTxMockRecorder) Rollback(ctx any) *MockTxRollbackCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockTx)(nil).Rollback), ctx)
	return &MockTxRollbackCall{Call: call}
}

// MockTxRollbackCall wrap *gomock.Call
type MockTxRollbackCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxRollbackCall) Return(arg0 error) *MockTxRollbackCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxRollbackCall) Do(f func(context.Context) error) *MockTxRollbackCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxRollbackCall) DoAndReturn(f func(context.Context) error) *MockTxRollbackCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
